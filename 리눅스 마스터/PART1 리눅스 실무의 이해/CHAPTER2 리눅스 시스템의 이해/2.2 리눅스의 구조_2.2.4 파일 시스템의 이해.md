# PART1 리눅스 실무의 이해[CHAPTER2 리눅스 시스템의 이해]


<br>


### 2.2 리눅스의 구조

#### 2.2.4 파일 시스템의 이해 

- 파일 시스템의 개요 
    - 파일 시스템은 파일에 이름을 붙이고 저장, 탐색을 위해 파일을 어디에 위치 시킬 것인지 나타내는 체계
    - 파일들이 디스크 상에서 구성되는 방식
    - 운영체제 설치-> 파티션분할 -> 포맷
    - 포맷 : 고유한 파일 시스템 구축, 다양한 규칙 설정 
    1. 파일 시스템의 기능
        - 사용자가 파일을 생성, 수정, 삭제할 수 있도록 제공
        - 사용자가 파일을 사용하기 적합한 형태의 구조로 구성, 다양한 추가 정보 제공
        - 다른 사용자와의 파일을 공통으로 사용할 수 있는 적절한 제어 방법 제공
        - 파일 공유를 위하여 판독 접근, 기록 접근, 수행 접근 등의 다양한 접근 제어 방법 제공
        - 정보 손실이나 파괴를 방지하기 위하여 백업이나 복구를 위한 기능 준비
        - 사용자와 장치 간의 독립성을 유지하기 위해, 사용자가 물리적인 장치 이름 대신에 적절한 이름 제공
        - 정보가 안전하게 보호되고 비밀이 보장될 수 있도록 정보의 암호화 및 복호화 기능 제공 
        - 사용자가 파일이ㅏ 디렉터리에 접근하기 쉬운 인터페이스 및 명령어 제공

    - 리눅스 파일 시스템의 개요
        - minix -> ext1 -> ext2 -> ext3(저널링 파일 시스템) -> ext4(최대 파일 크기, 파일 시스템 크기 확장) -> XFS
        
        ![파일 시스템](https://user-images.githubusercontent.com/93310395/223048609-3a929a21-49fc-49d9-80f8-146594407604.jpg)


    - 저널링 파일 시스템
        - 파일시스템에 대한 변경사항을 반영하기 전에 저널이라 부르는 로그에 변경사항을 저장하여 추적이 가능하게 만든 파일 시스템
        - 시스템에 충돌현상이 발생하거나 전원 문제가 발생된 경우에 데이터 복구 확률 높여줌  
        - ext2 오류 발생>>fsck 작업(슈퍼블록, 비트맵 등 검사)-> 저널링 오류 발생 >> 저장된 로그 확인

    - ext 파일 시스템의 구조
        - I-list : 아이노드 번호의 목록
        - 정보 저장 위치 : Directory Blocks and Data Blocks
        - 디렉터리 블록 : 아이노드 번호, 파일명
        - 데이터 블록 : 파일이 보관해야할 정보 

        ![mkfs](https://user-images.githubusercontent.com/93310395/223048622-9a2892d8-510b-459a-ad8c-6302b0c1eedf.jpg)

        ![inode](https://user-images.githubusercontent.com/93310395/223048623-3f49ad58-81d1-48ae-bf2d-618e5a9e4e38.jpg)

        - 관련 용어 
            - mkfs (Make Filesystem) : 파일시스템 생성
                - #mkfs [옵션] [타입] [장치명]
            - Boot sector
                - Block Group 앞에 위치, MBR와 LILO GRUB가 저장 
                * MBR = Master Boot Record
                * LILO = Linux Loader
                * GRUB = Grand Unified Bootloader
            - Block
             - Disk를 일정한 크기의 block으로 나누어 저장, 크기 4KB     
                - super block : File System에 대한 전반적인 정보가 저장되어
                - Allocation structure block : inode struct와 data에 대해 used/unused 정보
                - Key meta data block : inode struct의 table이 저장
                - User data block : 실제 data들이 저장

        ![EXT2](https://user-images.githubusercontent.com/93310395/223051436-4a021465-c70f-4e45-8d7b-3908fd3a230a.JPG)

        - 관련 용어
            - 블록 비트맵 : 블록의 사용 현환을 비트로 표현, 자유 공간(1), 할당공간(0)으로 표시 
            - 아이노드 비트맵 : 아이노드 할당 상태를 비트로 표현
            - 아이노트 테이블 : 아이노드 정보,'ls-l' 명령 실행시 나타남
            - 데이터 블록 : 파일 데이터 존재
                - 간접 블록 : 추가적인 데이터 블록을 위한 포인터들이 사용할 동적 블럭
                - 홀 : 아이노드나 간접블록 안의 데이터 블록의 주소, 디스크 할당 없고 파일안 0byte
    - XFS
        1. 개요
            - 1993년 실리콘 그래픽스 (SGI)가 만든 고성능 64비트 저널링 파일 시스템
            - RHEL 7부터는 기본 파일 시스템으로 지정
        2. 주요 특징
            - 저널링 : 메타데이터 저널링 지원 - 빠른 복구 가능
            - 신속한 트랜젝션 : 데이터 읽기, 쓰기 트랜잭션으로 인한 성능 저하 최소화
            - 높은 확장성 : 마운트되어 활성화된 상태로 조각 모음 및 확장 지원
            - 뛰어난 처리량 : xfs는 거의 raw IO 성능에 가까운 성능을 낼 수 있는 파일 시스템
            - 익스텐트 기반 할당 
                - 메타데이터에 의해 소비되는 공간 및 조각화를 줄임으로써 대용량 파일의 성능을 향상
                    - 지연 할당 : 파일이 연속적인 블록 그룹에 기록될 가능성을 높이는 것으로 단편화를 줄이고 성능을 향상
                    - 사전 할당 : 애플리케이션이 사전에 기록해야 할 데이터양을 알고 있는 경우 완전히 조각화하는 것을 방지 
        3. XFS의 자료 구조
            - B-트리
                - 데이터베이스와 파일 시스템에서 널리 사용되는 트리자료구조의 일종
                - 이진 트리 확장 : 자식 노드의 최대 숙자 2보다 큰 트리
                - 균등한 응답속도 : 리프레벨에서 좌우 균형 유지
                    - 모든 노드는 최대 m개의 자식 
                    - 루트노드와 리프 노드가 아닌 모든 노드는 최소 m/2개의 자식
                    - k개의 자식을 가진 리프 노드가 아닌 노드 k-1 = 키가 n개 있으면 이 노드의 자식은 n+1개
                    - 모든 리프노드들은 같은 높이 위치
                    - 순차 검색 느림
                    - 시간 복잡도 : O(logN)
                    
           ![b-tree](https://user-images.githubusercontent.com/93310395/223784010-cfc844c7-d19d-4c28-b936-78b2532642b4.JPG)
         
            - B+ 트리
                - 순차검색 향상을 위해 Index Set과 Data Set을 구분
                - 키에 의해서 각각 식별되는 레코드의 효율적인 삽입, 검색과 삭제를 통해 정렬된 데이터를 표현하기 위한 트리 자료구조 
                - 레코드들이 트리의 가장 하위 레벨에 정렬되어 있음
                    - 리프노드간에 연결리스트가 구성되어 순차 탐색가능
                - 순차검색 향상을 위해 index Set과 Data Set구분
                - 블록 인덱싱을 위해 B+트리 타입을 이용하는 파일 시스템 : ReiserFS filesystem (Unix and Linux), XFS filesystem (IRIX, Linux), JFS2 filesystem (AIX, OS/2, Linux) 등
        4. XFS 데몬
            - 기본 4가지 : xfssyncd, xfbudfd, xfsdatad/[cpu], xfslogd/[cpu]
                - xfssyncd : 로그 정보와 메타 데이터 정보들을 기록 - xfs_syncsub() 함수를 호출
                - xfbudfd : I/O 요청을 처리 - pagebuf_iostrategy() 함수와 blk_run_address_space() 함수를 호출
            - xfssyncd와 xfsbufd 데몬은 CPU의 수에 관계없이 하나씩만 존재
            - xfsdatad와 xfslogd 데몬은 SMP 시스템의 경우 각 CPU마다 하나씩 존재
        5. XFS 디스크 구조
            - 할당 그룹
                - 각각의 할당 그룹은 독립적으로 존재하며 병렬적으로 처리
                - 기본적으로 주어진 디스크를 8등분하여 8개의 할당 그룹을 생성
                - 0번 블럭에는 슈퍼 블럭 정보가 유지, 그외 블럭들에는 할당 그룹 헤더 정보 존재 
                - 마운트 시 슈퍼 블럭만 사용, 나머지는 슈퍼 블럭 응급 복구 시 사용
                - XFS의 슈퍼 블럭 구조체는 에 xfs_sb_t로 정의
            - 아이노드 
                - XFS 아이노드 구조체는 xfs_inode_t로 정의
                - 디스크에 직접 기록되는 아이노드의 구조는 xfs_dinode_t (disk inode) 
                - XFS의 아이노드 가변적인 구조 - xfs_dinode_core_t :헤더 정보, 필요에 따라 union으로 정의된 멤버들을 추가
               





                     