# PART1 리눅스 실무의 이해[CHAPTER2 리눅스 시스템의 이해]


<br>


### 2.4 셸(shell)

#### 2.4.2 shell 프로그래밍의 개요

- 셸 프로그래밍의 개요
    1. 개요
        - 셸에서 사용되는 여러 명령어들을 모아 하나의 파일로 만드는 과정 => 셸 스크립트
        - 다양한 명령어와의 조합을 통해 사용자 환경에 맞도록 프로그래밍을 할 수 있음
    2. 셸 스크립트 작성하는 방법
        1. vi 편집긷 등을 사용해서 파일을 생성
            ex) $ vi who2.sh
        2. 첫 번째 줄은 사용할 셸 명시
            ex) bash를 사용할 경우 : #!/bin/bash
        3. 두 번째 줄부터는 원하는 명령 및 구문 등을 입력
            ex) #/bin/bash
                echo "Login List"
                who
        4. 스크립트 실행 가능한 파일로 만듦
            ex) $ chmod 755 who2,sh
        5. 실행
            ex) $./who2.sh

    3. 셸 스크립트 실행하기
        1. 경로(PATH) 등록
            - 사용자으 홈 디렉터리에서 셸 스크립트를 생성한 뒤에 실행하려면 파일명 앞에 반드시 ./ 붙여야 함
            - ./ : 현재 디렉터리 안 해당 파일을 실행
            - 일반 사용자 PATH 확인 : echo $PATH
            - 반복 사용 셸 스크립트 : mkdir~/bin , mkdir~/.local/bin에 등록
            - 홈디렉터리 PATH에 등록 : PATH=$PATH:$HOME
        2. 허가권 없이 셸 스크립트 실행하기
            1. 앞부분에 sh 명령 : $ sh who2.sh
            2. 앞부분에 source 명령 : $ source who2.sh
            3. 앞부분에 . : $ . who2.sh

- 셸 프로그래밍 문법
    1. 주석 
        - 프로그램에 대한 이해를 돕기 위해 사용되는 설명
        - 사용 예 
            - #!/bin/sh
            - #Auth: posein
            - #Work : hello world를 출력한다
            - echo "hello world" #문자열을 출력한다     

    2. 변수
        - 셸에서의 변수형은 문장열만을 가지며, C 언어처럼 변수형 선언 필요 없음
        - 사용법 
            - var=value
                - var 변수에 값 value를 저장
                - 셸에서 변수를 사용할 때 $을 붙여서 사용
                - 대입연산자 =, 연산자/피연산자 사이에는 공백이 있으면 안 됨
                - -를 제외한 특수 문자와 숫자 사용 시작 안 됨
                - 기타 변수 대응법

                    |종류|설명|
                    |----|----|
                    |${name}|name이라는 변수 값으로 치환, 변수명 다음에 다른 문자가 연이어 나올 경우 유용|
                    |${name:=value}|name이 null이면 value 할당 저장, name에 값이 있으면 그 값을 사용함, 변수의 기본값을 지정할 때 유용|
                    |${name:+value}|기존 name이 null이 아니라면 value를 사용하지만, name에 저장 하지 않음(1회 사용)|
                    |${name:-value}|기존 name 값이 있다면 그 값을 사용하고, 값이 없으면 value 값 대입, name에 value 값은 저장 안 함|
                    |${name:?value}|기존에 name 값이 있다면 기본값으로 하고, 없으면 error를 내면서 value 값 출력|
                    |${name}|name의 문자열 길이를 반환|
                    |${name:offset}|name 값에서 offset만틈 삭제한 후에 값을 반환|
                    |${name:offset:length}|name 값에서 offset만큼 삭제한 후에 length만큼 센 뒤 값을 반환|

                - 관련 환경 변수

                    |종류|설명|
                    |---|---|
                    |$IFS|입력필드 구분자로서 셸 상에서 입력을 읽어 들일 때 글자를 구분하기 위해 사용되는 문자 목록|

                - 이규먼트(Argument)변수 
                    - 특별한 내장 변수로 '위치 매개 변수'라고도 함
                    - 매개변수를 불러올 때 스크립트의 명랭행 인자를 담당

                    |종류|설명|
                    |---|---|
                    |$0|실행된 셸 스크립트명|
                    |$1|스크립트에 넘겨진 첫 번째 아규먼트|
                    |$2|스크립트에 넘겨진 두 번째 아규먼트|
                    |$#|스크립트에 넘겨진 아규먼트 개수|
                    |$$|셸 스크립트의 PID|
                    |$*|스크립트에 전달된 인자 전체를 하나의 변수에 저장하면 IFS 변수의 첫 번째 문자로 구분|
                    |$@|$*와 동일(IFS 환경변수를 사용하지 않음)|
                    |$?|실행한 뒤의 반환 값, 즉 참이면 0, 거짓이면 1이 반환|
                    |$-|현재 Shell이 호출될 때 사용한 옵션들|

                    - 사용 예 
                        - "this is the 2nd"로 출력
                            ![image](https://user-images.githubusercontent.com/93310395/229342580-0275014e-a326-4211-a245-33c99001885f.png)

                        - DIR 값이 null인 경우에 temp를 대입하지만, 저장하지는 않음   

                        ![image](https://user-images.githubusercontent.com/93310395/229342810-713d3bf1-4e7e-4122-bd82-f944d71437bd.png)

                        - shell 변수 관련 명령어
                            |명령|설명|
                            |---|---|
                            |set|셸 변수를 출력하는 명령, 리눅스에서는 셸의 환경과 관련된 변수, 함수 등도 출력|
                            |env|환경 변수를 출력하는 명령, export된 변수는 이 명령으로 확인해야 하고, 상용자가 선언한 셸 변수 정보도 함께 출력|
                            |export|측정 변수의 범위를 환경 데이터 공간으로 전송하여 자식 프로세스에서도 특정 변수를 사용 가능|
                            |unset|선언된 변수 제거|

                            ![image](https://user-images.githubusercontent.com/93310395/229343588-0dc908f5-389c-423d-8b46-95dd30b23833.png)

                            - 셸 변수로 선언한 user1 경우에는 set 명령으로 확인 가능, export로 선언한 user2는 env로 확인 가능 

    3. echo문과 escape 문자
        - echo문은 라인을 제어하는 명령어해석기, -e 옵션과 값이 \으로 시작하는 escape 특수 문자 사용가능
            - escape 특수 문자의 종류
                |종류|설명|
                |---|---|
                |\f|폼피드(formfeed), 앞 문자열만큼 열을 밀어서 이동|
                |\n|새로운 줄로 바꿈|
                |\r|캐리지 리턴, 앞 문자열의 앞부분부터 뒷 문자열 만큼 대체하고 반환|
                |\t|탭만큼 띄운다|
                |\\|\를 표기|
            
            - 사용 예
                    ![image](https://user-images.githubusercontent.com/93310395/229344213-b917f59e-1b27-4c2e-ae43-d9a1002a0316.png)

                    - 앞 문자열의 yuloje를 받아서 앞부분부터 alin으로 대체한 후 출력
    
    4. 간단한 조건식
        - 명령행에서는 test 명령어를 이용하여 간단히 비교할 수 있고, 셸 스크립트에서는 보통 if문과 같이 사용
        - test 명령어를 생략하고 [] 사용
        - 사용법
            - 표현식
                - 문자열 비교 표현식
                    |종류|설명|
                    |----|----|
                    |[string1]|string1이 빈 문자열이 아니라면 참|
                    |[string1 = string2]|두 문자열이 같다면 참|
                    |[string1 != string2|두 문자열이 다르면 참|
                    |[-n string}|문자열이 null이 아니라면 참|
                    |[-z string}|문자열이 null이면 참|

                - 산술 비교 표현식
                    |종류|설명|
                    |----|----|
                    |[expr1 -eq expr2]| 두 표현식 값이 같다면 참|
                    |[expr1 -ne expr2]| 두 표현식 값이 같지 않다면 참|
                    |[expr1 -gt expr2]| expr1 > expr2이면 참|
                    |[expr1 -ge expr2]| expr1 >= expr2이면 참|
                    |[expr1 -lt expr2]| expr1 < expr2이면 참|
                    |[expr1 -le expr2]| expr1 <= expr2이면 참|
                    |[! expr}|expr이 참이면 거짓, 거짓이면 참|
                    |[expr1 -a expr2]| expr1 ANd expr2의 결과, 즉 둘 다 참|
                    |[expr1 -o expr2]|expr1 OR expr2의 결과, 둘 중 하나만 참|

                - 파일 조건 표현식
                    |종류|설명|
                    |----|----|
                    |[-b FILE]| FILE이 블록 디바이스면 참|
                    |[-c FILE]| FILE이 문자 디바이스면 참|
                    |[-d FILE]| FILE이 디렉터리면 참|
                    |[-e FILE]| FILE이 존재하면 참|
                    |[-f FILE]| FILE이 존재하고 정규 파일이면 참|
                    |[-g FILE]| FILE에 SGID가 있으면 참|
                    |[-k FILE]| FILE에 Sticky bit가 있으면 참|
                    |[-L FILE]| FILE에 심볼릭 링크면 참|
                    |[-p FILE]| FILE이 Named pipe면 참|
                    |[-r FILE]| 현재사용자가 읽을 수 있는 파일이면 참|
                    |[-s FILE]| 파일이 비어있지 않으면 참|
                    |[-S FILE]| 소켓 디바이스면 참|
                    |[-t FILE]| FD가 열려진 터미널이면 참|
                    |[-u FILE]| FILE에 SUID가 있으면 참|
                    |[-W FILE]| 현재 사용자가 쓸 수 있는 파일(writable)이면 참|
                    |[-x FILE]| 현재 사용자가 실행할 수 있는 파일이면 참|
                    |[-O FILE]| FILE의 소유자가 현자 사용자면 참|
                    |[-G FILE]| FILE의 그룹이 현재 사용자의 그룹과 같으면 참|
                    |[FILE1 -nt FILE2]|FILE1이 FILE2보다 새로운 파일이면 참|
                    |[FILE1 -Ot FILE2]|FILE1이 FILE2보다 오래된 파일이면 참|
                    |[FILE1 -et FILE2]|FILE1이 FILE2의 하드링크, i-node 값이 같으면 참|


                    - 사용 예
                        ![image](https://user-images.githubusercontent.com/93310395/229345336-f55b61c4-ca48-4a98-8ae2-8787a8c53d38.png)

    5. 조건문
        1. if문 
            - 참인지 거짓인지 판단할 때 사용 
            - if로 시작하면 반드시 'fi'로 끝나야 함
            - 사용법
                1. 형식1(단일 if)
                    if[조건]
                    then
                        실행문장
                    fi 
                    
                2. 형식2(if~ else)
                    if[조건]
                    then
                        실행문장1
                    else
                        실행문장2    
                    fi 
                3. 형식3(if ~elif):elif는 else if의 약자
                    if[조건1]
                    then
                        실행문장1
                    elif[조건2]
                    then
                        실행문장2
                    else
                        실행문장3        
                    fi 

        2. case문
            - 문자열고 일치하는 정규식 부분을 찾아 해당하는 정규식 다음에 있는 명령어를 실행
            - 사용법
                case 문자열
                in  
                    정규식1) 명령어1;;
                    정규식2) 명령어2;;
                ...
                esac

                : 오른쪽 괄호와 세미콜론, esac을 반드시 적어야 함

        3. select문
            select 변수 in 값1, 값2...
                do
                    실행문장
                done
            
            :in 다음에 나오는 값들이 항목으로 된 메뉴로 생성, 값이 생략되면 "$@" 가 됨
            :형식은 번호를 선택 =>  "변수"에 선택된 내용을 저장 => 선택된 번호는 내장 변수인 REPLY에 저장 => "실행문장"이 실행
    
    6. 반복문 
        1. for문
            - in뒤에 있는 값1, 값2.. 가 순서대로 지정된 변수에 배정되면서 do 이하의 문장을 수행
            - 사용법 
                for 변수 in 값1, 값2
                do
                    실행문장
                done
        2. while문
            - while 뒤의 조건문이 참일 동안 do 이하의 문장 실행
            - 사용법
                while 조건문
                do
                    실행문장
                done
        3. until문
            - until 뒤의 조건문이 거짓일 동안 do 이하의 문장 실행
            - 사용법
                while 조건문
                do
                    실행문장
                done                    
    
    7. 함수
        - 명령어 그룹을 메모리내에 정의하여 수헹 속도를 향상
        - 사용법
            1. 함수이름()
                {
                    command
                }
            2. function 함수 이름
                {
                    command
                }    

    8. 패턴과 패터비교
        - 문자열을 연산하는 것으로 특정한 패턴을 놓고 변수의 문자열 값이 일부분이라도 이 패턴과 일치하는지 검사할 때 쓰임
        |종류|설명|
        |---|---|
        |${variable#pattern}| 처음부터 pattern과 맞는 variable의 부분을 찾아 이 중 가장 작은 부분을 제거하고 나머지를 반환|
        |${variable##pattern}| 처음부터 pattern과 맞는 variable의 부분을 찾아 가장 큰 부분을 제거하고 나머지를 반환|            
        |${variable%pattern}| 끝에서부터 pattern과 일치하는 variable 부분을 찾아 최소 부분을 제거하고 나머지 반환|
        |${variable%%pattern}|끝에서부터 pattern과 일치하는 variable 부분을 찾아 최대 부분을 제거하고 나머지를 반환}

- 셀 프로그래밍 기타 사항
    1. 종료 코드(exit code)
        - 리눅스에서 사용되는 종료 코드는 0~255까지 사용
        - 주요 종료 코드
            |종료 코드|설명|
            |----|---|
            |0|성공|
            |1|일반적인 오류|
            |2|셸 내장 명령의 틀린 사용|
            |126|파일 실행 가능하지 않음|
            |127|명령어를 찾을 수 없음|
            |128|종료할 때 잘못된 인수 적용|
            |128+n|치명적인 시그널 n 에러|
            |130|[ctrl]+[c} 키 조합에 의한 종료|
    2. 우선순위
        1. 앨리어스(alias)
        2. function, if, for과 같은 지정 키워드
        3. 함수
        4. type이나 export 등과 같은 내장 명령어
        5. 스크립트, 프로그램, PATH 환경 변수에 들어 있는 디렉터리를 셸 확인

- 셸 프로그래밍 관련 명령어
    1. read 
        - 임의의 값을 키보드로부터 입력받는 명령어
        - 사용법
            - read 변수1 변수2...

    2. echo
        - 해당 문자열을 표준 출력에 표시하고 행 바꿈, 문자열 없을 시 행바꿈만 실행
        - 사용법
            - echo[option][문자열]
            - 주요 옵션
                |옵션|설명|
                |---|---|
                |-n|출력 결과에서 행 바꿈을 하지 않음|
                |-e|escape 문자를 사용가능하게 함|

    3. break
        - for,while, until의 순환문에서 빠져 나오게 하는 명령어
        - 사용법
            - break[n] : 순환문의 n번째 루트에서 빠져나온다 

    4. continue
        - for,while, until의 순환문을 계속 실행하게 하는 명령어
        - 사용법 
            - continue[n] 

    5. exit
        - 상태코드가 n가 함께 스크립트를 종료
        - n은 성공(0), 실패(1) 등의 숫자가 될 수 있음, n이 주어지지 않으면 최근에 사용된 명령의 상태 코드를 사용
        - 사용법
            - exit[n]

    6. function
        - 함수를 정의, 위치 매개 변수($1, $2 등) 사용가능
        - 사용법 
            - function 함수명
            {
                명령어
            }

    7. getopts
         - 명령행 인자를 처리해 올바른지 점검 
         - 셸 스크립트 순환문에서 사용되며 명령행 옵션이 표준 형식에 맞는지 확인
         - 사용법 
            - getopts 문자열 변수명

    8. return
        - 함수정의에서 사용되며 함수가 종료될 때 상태 코드 n를 반환 
        - 생략될 시 직전의 상태코드가 출력
        
    9. set
        - 특별한 옵션 없이 set입력시 셸변수와 값 출력
        - 변수와 값을 선언할 때 사용, bash에서는 생략 가능
        - 사용법
            - $ set [option] [문자열]
        - 주요 옵션
            |옵션|설명|
            |---|---|
            |-f|셸에서 *,?와 같은 와일드 카드 문자를 이용한 확장을 없앤다(= -o noglob)|
            |-C|리다이렉션 기호인 >를 이용한 파일의 덮어쓰기 제한(= -o noclobber)|
            |-o|bash의 화경 설정 관련 값을 확인하고 설정하는 옵션|

    10. shift
        - 위치 매개 변수를 이동할 때 사용
        - 사용법
            - shift[n] : 위치 매개 변수를 n만큼 이동하는데, 만약 n이 생략되면 기본적으로 1적용($2->$1로 $3->$2로 이동)
    11. source
        - 지정한 텍스트 파일의 내용을 읽고 실행
        - 사용법
            - source 파일 [인수]
            - .파일 [인수]
    12. eval
        - 인자값을 구하는데 사용하고 만약 값이 명령어와 같은 문자열이 경우 해당 명령 실행
    13. expr
        - 인자로 사용되는 표현식의 삾을 구할 때 사용 
        - 셸 상태에서 연산자 * 앞에 \를 붙여야 하고, 값과 연산자 사이에는 반드시 한 칸 띄워야 함 
        - 사용법
            - $ expr 값 연산자 값
    14. prinft
        - 형식화된 출력을 할 때 사용
        - 사용법 
            - printf "format string" parameter1 parameter2
            - 주요 format string
                - %d : 십진수 입력
                - %c : 한 문자 출력
                - %s : 문장 출력
                - %% : % 문자 출력
    15. ture
        - 셸 상에서 참의 의미를 가지는 0를 반환
        - 셸 스크립트 상에서 무한 루프를 만들 떄 사용
        - 사용법 
            - ture
    16. type
        - 주어진 이자가 셸 스크립트, 함수, 앨리어스인지를 검사하여 출력
        - 사용법
            - type [option] 인자
            - 주요 옵션
                |옵션|설명|
                |---|---|
                |-all|지정한 인자 이름으로 정의된 모든 정보 출력|
                |-path|실행 파일이나 셸 스크립트에 한정하여 관련 정보 출력|
                |-type|인자 이름과 일치하는 키워드 하나만 출력|
